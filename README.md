```
 __          __        _       _                                                  
 \ \        / /       | |     (_)                                                 
  \ \  /\  / /__  _ __| | __   _ _ __     _ __  _ __ ___   __ _ _ __ ___  ___ ___ 
   \ \/  \/ / _ \| '__| |/ /  | | '_ \   | '_ \| '__/ _ \ / _` | '__/ _ \/ __/ __|
    \  /\  / (_) | |  |   <   | | | | |  | |_) | | | (_) | (_| | | |  __/\__ \__ \
     \/  \/ \___/|_|  |_|\_\  |_|_| |_|  | .__/|_|  \___/ \__, |_|  \___||___/___/
                                         | |               __/ |                  
                                         |_|              |___/                   
```

# AUDALF (Almost Universal Dictionary And List Format)

AUDALF is binary format specification for (de)serializing dictionaries and lists.

## Why?

Because I needed something like this for my personal project

## Key features

* By default everything is assumed to be 64 bit (8 bytes) little endian
* Every index, structure, element etc. is aligned for 64 bit access
* Most common types for data are predefined (booleans, int64s, strings, byte arrays etc.)
* You can define your own types if needed 

## Implementations 

C# implementation can be found from [here](https://github.com/mcraiha/CSharp-AUDALF)

## What are the negative traits?

There are usually lots of 0x00 bytes because of alignments and making things future proof. So storage space wise this isn't optimal format. Also 64 bit little endian CPU assumption makes things a bit hard for other type of CPUs.

Also dictionaries must have same key type (value types can be different between pairs) and NULL keys are not allowed.

## License

Specifications are licensed under [Unlicense](LICENSE), so you might use these specs as you want.

## Version history

0.2 Added first sample file
0.1 First working draft

## Sample files

### Byte array (or list)

Bytes `0, 1, 10, 100, 255` in array/list would produce following AUDALF output if comments and hex values would be used

```
/* FOURCC */ 0x41, 0x55, 0x44, 0x41, 
/* VERSION NUMBER */ 0x01, 0x00, 0x00, 0x00, 
/* SIZE OF WHOLE ARRAY */ 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* INDEX COUNT */ 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY TYPE */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ADDRESS OF INDEX #1 */ 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ADDRESS OF INDEX #2 */ 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ADDRESS OF INDEX #3 */ 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ADDRESS OF INDEX #4 */ 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ADDRESS OF INDEX #5 */ 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY #1 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* VALUE TYPE ID #1 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ACTUAL VALUE #1 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY #2 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* VALUE TYPE ID #2 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ACTUAL VALUE #2 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY #3 */ 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* VALUE TYPE ID #3 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ACTUAL VALUE #3 */ 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY #4 */ 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* VALUE TYPE ID #4 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ACTUAL VALUE #4 */ 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 

/* KEY #5 */ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* VALUE TYPE ID #5 */ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
/* ACTUAL VALUE #5 */ 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
```
and actual file can be found [SAMPLES/bytes_0_1_10_100_255.audalf](SAMPLES/bytes_0_1_10_100_255.audalf)

### int array (or list)

Ints `0, 1, 10, 100, 255, 16777216, 2147483647` in array/list would produce following AUDALF output if comments and hex values would be used

```
0x41, 0x55, 0x44, 0x41, /* FOURCC */ 
    
0x01, 0x00, 0x00, 0x00, /* VERSION NUMBER */
    
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* SIZE OF WHOLE ARRAY */

0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* INDEX COUNT */

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY TYPE */

0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #1 */ 
0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #2 */ 
0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #3 */ 
0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #4 */ 
0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #5 */ 
0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #6 */ 
0xe8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ADDRESS OF INDEX #7 */ 

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #1 (zero based index 0) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #1 */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #1 */

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #2 (zero based index 1) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #2 */
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #2 */

0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #3 (zero based index 2) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #3 */
0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #3 */

0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #4 (zero based index 3) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #4 */
0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #4 */

0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #5 (zero based index 4) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #5 */
0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #5 */

0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #6 (zero based index 5) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #6 */
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* ACTUAL VALUE #6 */

0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* KEY #7 (zero based index 6) */
0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* VALUE TYPE ID #7 */
0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00  /* ACTUAL VALUE #7 */
```
and actual file can be found [SAMPLES/ints_0_1_10_100_255_16777216_2147483647.audalf](SAMPLES/ints_0_1_10_100_255_16777216_2147483647.audalf)